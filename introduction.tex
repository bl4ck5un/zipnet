%!TEX root = main.tex

\section{Introduction}
Strong anonymous communication is a well studied problem~\cite{}. Indeed, it's a well understood trade off that you can only have either low latency or low bandwidth.

In an anonymous broadcast setting, users attempt to anonymously announce a message to all users. In concept, this can be modeled as a channel whose capacity C is the size of a single message. User's would then take turns. However, in practice, channels usually have large capacity relative to the message size and multiple users can broadcast at once.

Concurrent Anonymous broadcast protocols must accomplish three tasks
\begin{enumerate}
	\item anonymously broadcast a message
	\item provide a channel access method for allowing multiple parties to use the broadcast channel
	\item provide some mechanism to prevent disruption
\end{enumerate}

To date, there have been two approaches. In \emph{shuffling protocols}~\cite{CCS:LYKGKM19,USENIX:AKTZ17} all encrypted messages are collected by a set of servers and then shuffled and decrypted using techniques from multi party computation. Unfortunately, shuffling protocols scale super linearly in the size of the number of messages in the round.  XXXX CHECK

The other approach, is that of a DC-net~\cite{JC:Chaum88}: each user submits a broadcast that obfuscates which part of the channel (if any) it writes to.  These broadcasts can then be combined to produce the final broadcast. Crucially, the combination process

In the original DC networks, this process was accomplished  by all parties, pairwise, sharing $|C|$ random coins.

There have been two advances
\begin{itemize}
	\item The any trust model ~\cite{CCS:CorFor10}: instead of all parties communicating we pick a small number of servers who are trusted for availability and that at least one is honest. This avoids quadratic bandwidth usage and reduces each clients bandwidth requirement to simply $O(C)$: a single channel capacity length message to one of the servers. However, the network must still handle $O(Csn)$ data: i.e. bandwidth usage scales linearly in both the number of servers and the number of clients.
	\item The distributed point function approach. First introduced in~\cite{SP:CorBonMaz15}, uses cryptography to shorten the message each user submits to $O(\sqrt(C))$
\end{itemize}


\subsectiton{Scheduling }
A common approach to scheduling (e.g., in Dissent~\cite{CCS:CorFor10}) is a verifiable shuffle.  We observe that with careful design, verifiability of the shuffle is not necessary and can be handled by an accusation phase.

In our protocol, each user submits a ephemeral epoch key via a traditional mixnet operated by each server in the any trust set. The servers operate in lock step. I.e. each server waits until it has received all submissions before striping off the outer encryption layer and forwarding, in random order, the contents to the next server. At the end, we have a clear text list of ephemeral round keys which cannot be linked to the submitters.

In and of it self, however, this is insufficient.  The last sever in the any trust set could, for example,  collude to schedule only sybils and one victim user. To prevent this, we publicly shuffle the  output using randomness contributed by each anytrust server after the nextnet finishes.

Finally, any given server could drop honest users  by colluding with dishonest ones. In particular, the initial server who learns the submitters IP address can target specific users. To prevent this, we rely on an accusation mechanism where anyone who had their scheduling key dropped would announce this along with proof (to whit, a signature form the first server saying they included a ciphertext along with the opening of the ciphertext)


Security argument consider an ideal functionality that on input a list of ciphertexts returns a permuted list of cleartext messages.

With out loss of generality, assume  3 servers and the middle one is honest. 

.....

FIXME: in the ideal functionality even dishonest messages get shuffled. In the real protocol we cannot detect if dishonest messages get substituted out 





