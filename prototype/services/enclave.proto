syntax = "proto3";

package rpc;

service enclave {
  rpc schedule(SchedulingRequest) returns(SchedulingResponse);
  rpc aggregate(AggregateRequest) returns (AggregateResponse);
}

message SchedulingState {
  uint32 round = 1;                  // round #
  repeated bool reservation_map = 2; // current reservation map. TODO: change this to map
  repeated string footprints = 3;    // current footprint
  string sig = 4;
  bool final = 5;                   // if set, this is the final round. Use this as a ticket.
  // Footprint scheduling paper says you send the final message to DC and ignore the outcome. Doesn't see to be needed.
}

// footprint scheduling
message SchedulingRequest {
  SchedulingState cur_state = 1; // current state
  string cur_dc_message = 2;     // message received from DC.
}

message DCNetBroadcast {
  string sched_msg = 1;
  string user_msg = 2;
}

message DCNetSubmission {
  uint32 round = 1;
  string user_id = 2;
  string message = 3; // message = sched_msg || user_msg
  string sig = 4;
}

message SchedulingResponse {
  SchedulingState new_state = 1;    // new state
  string sched_msg = 2;  // message to be used in next DC net submission. This is here for convenience only, as it can be derived from new_state.
}

message AggregateRequest{
  DCNetSubmission submission = 1;
  Aggregation current_agg = 4;
}

message Aggregation {
  repeated string user_id_in_aggregation = 1;
  string current_aggregated_value = 2;
  string sig = 3;
}

message AggregateResponse{
  Aggregation new_agg = 1;
}

message Empty {}
